<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://shili2017.github.io/</id><title>Li Shi</title><subtitle>Li Shi</subtitle> <updated>2023-06-14T03:42:34+00:00</updated> <author> <name>Li Shi</name> <uri>https://shili2017.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://shili2017.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://shili2017.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator> <rights> © 2023 Li Shi </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>《安全处理器架构设计原理》笔记（一）：基础</title><link href="https://shili2017.github.io/posts/PSPAD1/" rel="alternate" type="text/html" title="《安全处理器架构设计原理》笔记（一）：基础" /><published>2023-06-14T03:41:00+00:00</published> <updated>2023-06-14T03:41:00+00:00</updated> <id>https://shili2017.github.io/posts/PSPAD1/</id> <content src="https://shili2017.github.io/posts/PSPAD1/" /> <author> <name>Li Shi</name> </author> <category term="读书笔记" /> <category term="安全处理器架构设计原理" /> <summary> 《安全处理器架构设计原理》（英文名为Principles of Secure Processor Architecture Design）隶属于Synthesis Lectures on Computer Architecture系列。硬件不同于软件那样容易被破解，且基于硬件的安全保护效率更高，对系统性能的影响更小，但在硬件中增加安全功能也充满挑战，一旦实现之后就很难改变，需要仔细设计，且设计时需要考虑到适用于未来的功能和算法。 背景 安全处理器架构在设计上提供了额外功能，这些功能可以是纯硬件的，也可以是硬件和软件结合实现的。安全处理器架构一般是商业处理器的扩展，基于x86等架构实现，这些功能的出现基于以下三个因素： 软件的复杂性和缺陷：诸如操作系统、虚拟机之类的软件复杂性和规模逐渐上升，仅仅基于软件来提供安全性是不现实甚至不可能的，有必要实现硬件安全功能（如特... </summary> </entry> <entry><title>Chisel笔记（三）：一生一芯第三期项目中使用Chisel语言的一些心得体会</title><link href="https://shili2017.github.io/posts/CHISEL3/" rel="alternate" type="text/html" title="Chisel笔记（三）：一生一芯第三期项目中使用Chisel语言的一些心得体会" /><published>2023-04-23T19:41:00+00:00</published> <updated>2023-04-23T19:41:00+00:00</updated> <id>https://shili2017.github.io/posts/CHISEL3/</id> <content src="https://shili2017.github.io/posts/CHISEL3/" /> <author> <name>Li Shi</name> </author> <category term="Chisel" /> <summary> 知乎原回答：https://www.zhihu.com/question/468593551/answer/2996304673 差不多正好两年前开始接触体系结构这个领域，通过一生一芯第一期项目和rocket-chip了解到了chisel这个语言，在2021年下半年参加了一生一芯第三期，也许也算是有资格来回答这个问题吧w，chisel的优缺点楼上各位大佬已经讨论的非常充分了，或许我会更多从自己项目经历和主观体验的角度，作为chisel语言的用户来聊一聊，希望各位大佬前辈多多批评。 首先放上自己一生一芯第三期的项目链接：https://github.com/OSCPU-Zhoushan/Zhoushan 我自己的背景是从大二的数电课开始接触verilog，本科毕设做处理器设计的时候有考虑过用chisel，和队友讨论下来还是不要选这些稀奇古怪的新语言了。不过后来8月中旬开始一生一芯... </summary> </entry> <entry><title>2023年读书记录</title><link href="https://shili2017.github.io/posts/BOOKS/" rel="alternate" type="text/html" title="2023年读书记录" /><published>2023-03-19T17:08:00+00:00</published> <updated>2023-05-09T16:02:42+00:00</updated> <id>https://shili2017.github.io/posts/BOOKS/</id> <content src="https://shili2017.github.io/posts/BOOKS/" /> <author> <name>Li Shi</name> </author> <category term="其他" /> <summary> 很久没有读专业书以外的书了，也确实很久没有给自己喘一口气的机会了，决定开个新帖，记录一下2023年已经看完的书。 2023/03/13 《海外征程3》 2023/03/19 《挽救计划》 2023/04/16 《可能性的艺术：比较政治学30讲》 2023/05/09 《圆圈正义：作为自由前提的信念》 </summary> </entry> <entry><title>《虚拟内存的架构和操作系统支持》笔记（六）：异构系统与虚拟化</title><link href="https://shili2017.github.io/posts/VM6/" rel="alternate" type="text/html" title="《虚拟内存的架构和操作系统支持》笔记（六）：异构系统与虚拟化" /><published>2022-11-03T05:04:00+00:00</published> <updated>2022-11-03T05:04:00+00:00</updated> <id>https://shili2017.github.io/posts/VM6/</id> <content src="https://shili2017.github.io/posts/VM6/" /> <author> <name>Li Shi</name> </author> <category term="读书笔记" /> <category term="虚拟内存的架构和操作系统支持" /> <summary> 虚拟内存系统的设计空间正在不断扩展，也带来了全新的挑战，涵盖ISA设计、内存布局和管理、虚拟化等多个方面，虚拟内存实现的复杂度正在成倍增长。由异构系统和虚拟化带来的一些特殊挑战包括以下方面： 当被访问的数据在另一个设备甚至另一台机器上时，内存访问可能有更高的延迟； 设备的虚拟地址空间可能与某些主机进程的虚拟地址空间相同，也可能是其子集，也可能不相关； 很难处理page fault，通常加速器上不会运行操作系统； 实现跨设备的缓存一致性是非常困难和昂贵的，但是省略硬件实现的一致性会给程序员带来更大的负担； 面对不同的内存性能特征，对物理内存中的数据进行优化管理（分配、迁移和驱逐）成为一个不可忽视的难题； 在虚拟化系统中，内存访问和虚拟内存管理必须要么通过hypervis... </summary> </entry> <entry><title>《虚拟内存的架构和操作系统支持》笔记（五）：缓存与内存一致性</title><link href="https://shili2017.github.io/posts/VM5/" rel="alternate" type="text/html" title="《虚拟内存的架构和操作系统支持》笔记（五）：缓存与内存一致性" /><published>2022-10-22T05:27:00+00:00</published> <updated>2022-10-22T05:27:00+00:00</updated> <id>https://shili2017.github.io/posts/VM5/</id> <content src="https://shili2017.github.io/posts/VM5/" /> <author> <name>Li Shi</name> </author> <category term="读书笔记" /> <category term="虚拟内存的架构和操作系统支持" /> <summary> 我们在本章中讨论的基本内容是TLB通常不与内存系统的其他部分保持一致性，也就是说更新页表的操作不会自动传播到TLB中，且旧的TLB条目也不会自动失效。这种不一致性给程序员和操作系统增添了额外的负担，当虚拟内存的状态被更新时，需要明确地进行同步。我们在本章仔细研究TLB和一般情况下指令缓存不保证硬件上的一致性的额原因，接下来研究这种不一致性对程序的同步要求，包括单线程和多线程，最后我们简单讨论即使是保持了一致性的缓存也会在弱内存一致性模型中发生意外的行为。 不一致缓存和TLB 尽管大多数CPU都用硬件实现缓存一致性，但通常不会对TLB保持同样的一致性，这也是架构设计中对性能、功耗、面积、易用性之间的复杂权衡。数据缓存保存了频繁读写的数据，且有时由一个以上的核心同时读写，要求软件管理的话对程序员负担过重，因此架构师会使用硬件来实现一致性。 相比之下，TLB和指令缓存存储的数据大多是... </summary> </entry> </feed>
