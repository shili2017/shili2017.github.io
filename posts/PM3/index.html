<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="《处理器微架构实现》笔记（三）：分配与发射" /><meta property="og:locale" content="en" /><meta name="description" content="分配阶段包括两个任务：寄存器重命名和指令分派，前者的目的是消除由于寄存器的重复使用而产生的不必要的数据依赖，而后者的目的是保留一些指令执行所需的资源。发射阶段负责向FU发射指令并执行，通常可以分为顺序发射和乱序发射。" /><meta property="og:description" content="分配阶段包括两个任务：寄存器重命名和指令分派，前者的目的是消除由于寄存器的重复使用而产生的不必要的数据依赖，而后者的目的是保留一些指令执行所需的资源。发射阶段负责向FU发射指令并执行，通常可以分为顺序发射和乱序发射。" /><link rel="canonical" href="https://shili2017.github.io/posts/PM3/" /><meta property="og:url" content="https://shili2017.github.io/posts/PM3/" /><meta property="og:site_name" content="Li Shi" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-05-10T19:50:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="《处理器微架构实现》笔记（三）：分配与发射" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-10T19:50:00+00:00","datePublished":"2022-05-10T19:50:00+00:00","description":"分配阶段包括两个任务：寄存器重命名和指令分派，前者的目的是消除由于寄存器的重复使用而产生的不必要的数据依赖，而后者的目的是保留一些指令执行所需的资源。发射阶段负责向FU发射指令并执行，通常可以分为顺序发射和乱序发射。","headline":"《处理器微架构实现》笔记（三）：分配与发射","mainEntityOfPage":{"@type":"WebPage","@id":"https://shili2017.github.io/posts/PM3/"},"url":"https://shili2017.github.io/posts/PM3/"}</script><title>《处理器微架构实现》笔记（三）：分配与发射 | Li Shi</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Li Shi"><meta name="application-name" content="Li Shi"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Li Shi</a></div><div class="site-subtitle font-italic">Sleep every day</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/shili2017" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://www.linkedin.com/in/lishi2022" aria-label="linkedin" target="_blank" rel="noopener noreferrer"> <i class="fab fa-linkedin"></i> </a> <a href="javascript:location.href = 'mailto:' + ['shili2048','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>《处理器微架构实现》笔记（三）：分配与发射</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>《处理器微架构实现》笔记（三）：分配与发射</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1652212200" data-df="ll" data-toggle="tooltip" data-placement="bottom"> May 10, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/shili2017">Li Shi</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4221 words"> <em>23 min</em> read</span></div></div></div><div class="post-content"><p>分配阶段包括两个任务：寄存器重命名和指令分派，前者的目的是消除由于寄存器的重复使用而产生的不必要的数据依赖，而后者的目的是保留一些指令执行所需的资源。发射阶段负责向FU发射指令并执行，通常可以分为顺序发射和乱序发射。</p><h1 id="分配">分配</h1><p>如上所述，分配阶段由两大任务。首先是寄存器重命名，此处我们讨论的重命名只限于寄存器的范畴，事实上这个概念也适用于内存操作数，会在之后进一步讨论。寄存器重命名最早是在Tomasulo在上世纪60年代在<em>An Efficient Algorithm for Exploiting Multiple Arithmetic Units</em>中提出的，应用于IBM 360/91的浮点单元。现代处理器通常有三种重命名的方式：ROB重命名、Rename Buffer重命名与合并RF重命名。</p><h2 id="rob重命名"><span class="mr-2">ROB重命名</span><a href="#rob重命名" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="/assets/img/Book/PM/3-1.png" class="popup img-link "><img data-src="/assets/img/Book/PM/3-1.png" alt="3-1" class="lazyload" data-proofer-ignore></a> <em>ROB重命名</em></p><p>在这个设计中，寄存器的值既有可能存储在RF中，也可能存储在ROB中。如上图所示，Register Map Table会指明操作数应该从RF还是ROB中获取。当一条指令仍在执行时，目的操作数（即rd）的值会被存储在ROB中，在指令提交时，会把ROB中的值复制到RF中。</p><p>这一方案被Intel Core 2等处理器所采用。</p><h2 id="rename-buffer重命名"><span class="mr-2">Rename Buffer重命名</span><a href="#rename-buffer重命名" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>这个方案的动机在于，程序中有相当一部分比例的指令（大约为三分之一，但也要看具体的程序和指令集）不会写入寄存器。在之前的方案中，ROB每一行都要留出空间存储寄存器的结果，也就是说大约有三分之一的存储空间都被浪费了。这一设计的想法在于为每条正在执行的指令的结果提供一个单独的存储空间结构，也就是Rename Buffer。</p><p>和前一种方案一样，可以使用一个简单的FIFO来存储临时的寄存器数据，但也同样需要写入两次数据，第一次往Buffer里写入，第二次在指令提交时往RF写入。</p><p>这一方案被IBM Power 3等处理器所采用。</p><h2 id="合并rf重命名"><span class="mr-2">合并RF重命名</span><a href="#合并rf重命名" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="/assets/img/Book/PM/3-2.png" class="popup img-link "><img data-src="/assets/img/Book/PM/3-2.png" alt="3-2" class="lazyload" data-proofer-ignore></a> <em>合并RF重命名</em></p><p>在这个设计中，只有一个单独的物理寄存器堆来存放所有的寄存器值，每个寄存器都有一个状态（空闲或者被分配，也可以有更多的状态）。空闲寄存器被记录在空闲列表中，寄存器映射关系被记录在映射表中，具体的组织结构如上图所示。</p><p>在重命名阶段，我们首先查找映射表，找到rs1和rs2对应的物理寄存器。如果这条指令还需要写回寄存器，我们会从空闲列表中找到一个空闲的物理寄存器，分配给rd并写入映射表。如果没有空闲的寄存器，就需要停顿流水线。</p><p>这一设计的优势在于寄存器只需要被写入一次，且源操作数的值来自单一的RF，省去了往ROB或Rename Buffer寻找的过程，缩小了连线的面积。</p><p>这一方案被Alpha 21264、MIPS R12000、Pentium 4等处理器所采用。</p><h2 id="读取rf"><span class="mr-2">读取RF</span><a href="#读取rf" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>什么时候读取RF也很重要，会对设计的几个关键部分有重要影响，通常有两个选择：发射前读取和发射后读取。</p><ul><li><p>发射前读取：注意到指令发射时，可能并不是所有的源操作数都已经准备好了，这些操作数需要通过旁路网络获得。这种设计的优点在于RF需要的端口比较少，但缺点在于发射队列需要存储寄存器的值，面积较大，且需要不断的移动数据，功耗较高。</p><li><p>发射后读取：和前一种设计相反，这种设计要求RF有更多的端口，但操作数被读取一次就不用再反复挪动了。</p></ul><p>理论上，这两个选择和重命名方案是正交的，但也有一些需要考虑的“协同作用”，使得有些组合非常常见。比如说，ROB重命名或Rename Buffer重命名通常会和发射前读取共同使用，具体的原因如下。</p><blockquote><p>In particular, the challenge comes from the fact that the register values eventually move from one location (reorder buffer or rename buffer) to another (architectural register file). In the read- after-issue scheme, the issue queue stores the identifier of the source operands. If when an instruc- tion is renamed, a source operand is in the reorder buffer or the rename buffer, the issue queue will store a pointer to that location. If the instruction that produces this source operand commits before the operand is read by the consumer, the value will be moved to the architectural register file, and the pointer stored in the issue queue will not be correct anymore, since this entry may be allocated by a different instruction. In order to correct it, it would be necessary to do an associative search in the issue queue for every committed instruction to check if any entry is pointing to its destination register. If this is the case, the pointer should be changed to the corresponding architectural register file entry. All of this is very complex in hardware. The associative search is similar to the wakeup logic described later and, on top of that, additional write ports would be required to store the new pointer. Because of this, processors that use renaming through the reorder buffer or through the rename buffer normally opt for the read-before-issue scheme.</p></blockquote><h1 id="发射">发射</h1><h2 id="顺序发射"><span class="mr-2">顺序发射</span><a href="#顺序发射" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>顺序发射逻辑有时可以在解码阶段一并实现，通常使用Scoreboard实现，存储数据依赖和可用资源，前者对每个寄存器都存储了一个状态，表明该寄存器是否可用，后者记录了FU是否空闲，有些资源如加法器或Pipelined的乘法器总是空闲的，但有些资源如多周期的除法器则不一定。</p><h2 id="乱序发射"><span class="mr-2">乱序发射</span><a href="#乱序发射" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>发射逻辑决定了乱序处理器是否可以高效利用指令级别并行性（ILP），一旦源操作数可用，就立即把指令发射到对应的FU中。由于其功能的复杂性，实现一个高效且不影响关键路径的发射逻辑是非常重要的。</p><p>此处我们讨论那两种单一发射队列的设计，即发射前读取RF和发射后读取RF，我们假设采用合并RF重命名方案。除了单一发射队列之外也有其他的方案，如分布式发布队列。</p><h3 id="发射前读取rf的发射过程"><span class="mr-2">发射前读取RF的发射过程</span><a href="#发射前读取rf的发射过程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/img/Book/PM/3-3.png" class="popup img-link "><img data-src="/assets/img/Book/PM/3-3.png" alt="3-3" class="lazyload" data-proofer-ignore></a> <em>发射前读取RF发射队列的硬件组成</em></p><p>上图中每一个矩形都代表了一个表，行数等于发射队列中容纳的指令数量。我们假设采用RISC，最多可以有两个源操作数或一个源操作数加上一个立即数。Ctrl info保存了控制信号（如使用什么ALU、访存指令数据大小、是否使用立即数等），R1和R2表示两个源操作数是否已经可用，如果两个都为1，那么这条指令就可以发射了。接下来我们讨论具体的发射逻辑，包括发射队列分配、指令唤醒、指令选择和发射队列回收。</p><h4 id="发射队列分配"><span class="mr-2">发射队列分配</span><a href="#发射队列分配" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="/assets/img/Book/PM/3-4.png" class="popup img-link "><img data-src="/assets/img/Book/PM/3-4.png" alt="3-4" class="lazyload" data-proofer-ignore></a> <em>发射前读取RF发射队列的流水线设计</em></p><p>指令首先在分配阶段会被分派到发射队列，如果没有空闲的行，分配阶段就会停顿。接下来在下一个周期，指令访问寄存器堆。最后重命名后的指令被放入发射队列，并附上重命名相关的控制信号。</p><h4 id="指令唤醒"><span class="mr-2">指令唤醒</span><a href="#指令唤醒" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>唤醒是通知发射队列哪些源操作数已经准备好的一个事件，通常包括目标寄存器的物理寄存器ID、寄存器值以及一个有效位。CAM会把ID和发射队列中的每一个寄存器ID匹配，并设置相应的Ready位、把数据放到对应的位置中。这其中可能有一些细节需要处理，如对于发射前读RF的设计通常在重命名和发射队列分配之间要有一个额外的时钟周期，否则会产生死锁，具体的细节可以参考原书第6章。</p><p><a href="/assets/img/Book/PM/3-5.png" class="popup img-link "><img data-src="/assets/img/Book/PM/3-5.png" alt="3-5" class="lazyload" data-proofer-ignore></a> <em>唤醒信号产生的时机</em></p><p>唤醒这个概念比较有意思的一点在于，唤醒信号其实可以在实际产生一个值之前就发出，以尽量缩短Producer和Consumer之间的距离。在上图的例子中，与其到Write Back再发出唤醒信号，可以在指令在发射队列中被选中的那个周期就向其依赖的指令发出唤醒信号，之后在执行阶段可以直接通过旁路网络读取输入，以达到指令背对背的执行。需要注意的是这里我们假设FU只需要一个周期完成、且Producer的选择和Consumer的唤醒也可以在一个周期内完成。</p><p>这一优化对性能至关重要，有两种常见的实现方式来产生唤醒信号。第一种方法是在指令执行完成前的三个周期在指令所在的流水线产生唤醒信号，第二种方法则是使用移位寄存器或Scoreboard。另外也需要注意的是，这种机制只有在一条指令需要的周期数是确定的情况下才有效，也就是说对于访存指令并不适用。对访存指令也有一些单独的优化技巧，比如Load指令可以用保守的方式处理，但其实也可以用更激进的方式处理。</p><h4 id="指令选择"><span class="mr-2">指令选择</span><a href="#指令选择" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>这一部分负责在发射队列中选择一部分已经准备好可以发射的指令，发射到对应的FU。由于时许的原因，选择逻辑通常会放在唤醒逻辑之后的一个周期进行，并使用仲裁器或调度器之类的组件来完成。具体的选择逻辑也有很多选项，如可以根据指令的顺序，或者也可以简单地根据发射队列中的位置进行排序等。</p><p><a href="/assets/img/Book/PM/3-6.png" class="popup img-link "><img data-src="/assets/img/Book/PM/3-6.png" alt="3-6" class="lazyload" data-proofer-ignore></a> <em>基于仲裁器的选择逻辑的实现</em></p><h4 id="发射队列回收"><span class="mr-2">发射队列回收</span><a href="#发射队列回收" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>一旦一条指令被发射到FU，对应的发射队列行就可以被回收，但是也有一些激进的优化如推测性唤醒，可能需要等待这条指令真正被发射成功之后才可以回收（类似于ROB的逻辑）。</p><h3 id="发射后读取rf的发射过程"><span class="mr-2">发射后读取RF的发射过程</span><a href="#发射后读取rf的发射过程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/img/Book/PM/3-7.png" class="popup img-link "><img data-src="/assets/img/Book/PM/3-7.png" alt="3-7" class="lazyload" data-proofer-ignore></a> <em>发射后读取RF发射队列的硬件组成（灰色表示相比于之前的设计去掉的部分）</em></p><p><a href="/assets/img/Book/PM/3-8.png" class="popup img-link "><img data-src="/assets/img/Book/PM/3-8.png" alt="3-8" class="lazyload" data-proofer-ignore></a> <em>发射后读取RF发射队列的流水线设计</em></p><p>在这种设计中，发射队列不再需要存储寄存器的值。重命名和发射队列分配之间的流水线级数减少了，但唤醒逻辑和指令执行阶段之间需要多一个周期来读取RF。和前一种设计最重要的区别在于寄存器堆需要的端口数量，由发射宽度决定，且一般比前段的宽度更大。</p><h4 id="减少读端口"><span class="mr-2">减少读端口</span><a href="#减少读端口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>寄存器堆的面积、功耗和访问延迟随着读端口的数量增加而增加，因此为了实现高能效的设计，需要尽可能减少读端口的数量。Alpha 21264分成了两个一样的寄存器堆，以减少单个寄存器堆的读端口的数量，代价是访问不同寄存器堆的Producer和Consumer无法背对背地执行。</p><p>不过，大部分寄存器源操作数其实是从旁路网络读取的，且发射宽度通常不会被完全利用，因此其实可以减少寄存器读端口的数量。有两种方法：主动或被动。主动的方法中，我们计算每条被选择的指令需要的读端口的数量，如果太多，就取消发射其中一部分指令。被动的方法中，只有在需要读端口数量过多的情况下才进行处理，一部分指令被取消、放回发射队列并重新发射。注意在被动的方法中，可能会发生starvation甚至live lock，因而需要定义一个公平的发射策略。</p><h3 id="其他乱序发射的实现"><span class="mr-2">其他乱序发射的实现</span><a href="#其他乱序发射的实现" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li><p>分布式发射队列：每一个FU集群都有自己的发射队列，如Intel Pentium 4有两个队列：访存与非访存。</p><li><p>保留站：每一个FU都有自己的私有缓冲区，也就是Tomasulo在IBM 360/91中使用的方案。</p></ol><h2 id="访存操作的发射逻辑"><span class="mr-2">访存操作的发射逻辑</span><a href="#访存操作的发射逻辑" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>访存指令的数据依赖性是基于内存地址的，在重命名阶段无法确定，只有计算出地址之后才可以确定依赖关系，这种机制称为内存消歧（memory disambiguation policy），上图中展示了不同的方案，主要可以分为两类：非推测性和推测性，前者不允许在不确定依赖关系的情况下执行访存操作，而后者会对依赖关系做出预测并执行。</p><p>选择一个合适的策略很重要，一方面如果过于保守会导致不必要的访存指令按序执行，降低性能，另一方面如果过于激进则会导致复杂的错误恢复机制，增大功耗。</p><h3 id="非推测性内存消歧"><span class="mr-2">非推测性内存消歧</span><a href="#非推测性内存消歧" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在不确定依赖关系的情况下，这种策略不会执行任何访存操作，主要分为三种相关的策略：total ordering、load ordering with store ordering以及partial ordering。</p><ol><li><p>Total ordering：所有访存操作都是按序执行的，目前没有按照这种方式实现的乱序处理器。</p><li><p>Load ordering with store ordering：load与store分别按序执行，但load不需要等待之前的store，如AMD K6等。</p><li><p>Partial ordering：load可以乱序执行，只要源操作数准备好，且之前所有的store都已经计算出访存地址，就可以发出load请求，如MIPS R10000、AMD K8等。</p></ol><p>只要计算出访存地址，就可以进行内存消歧，因此一些处理器将store操作分为两个子任务：计算地址与存储数据。原书中给出了AMD K6和MIPS R10000的案例研究，此处就不再展开了。</p><h3 id="推测性内存消歧"><span class="mr-2">推测性内存消歧</span><a href="#推测性内存消歧" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>这种方案可以通过推测性地执行load指令来提升性能，load指令不需要等待先前的store来计算地址。注意到这个方案对依赖性进行推测，也就是说可能会发生错误，因此需要额外的硬件来识别错误并恢复正确执行。原书中给出了Alpha 21264的案例研究，此处也就不再展开了。</p><h2 id="load指令consumers的推测唤醒"><span class="mr-2">Load指令Consumers的推测唤醒</span><a href="#load指令consumers的推测唤醒" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="/assets/img/Book/PM/3-10.png" class="popup img-link "><img data-src="/assets/img/Book/PM/3-10.png" alt="3-10" class="lazyload" data-proofer-ignore></a> <em>Load指令与其Consumer的流水线</em></p><p>Load指令需要的周期数是不固定的。如上图所示，在保守的情况中，在缓存命中时才会唤醒下一条指令，会产生两个周期的气泡，但如果使用推测唤醒，就可以实现两条指令的背对背执行。不过，如果缓存未命中，Load指令的Consumer需要被放回发射队列并重新发射，且可能会导致死锁。</p><p>死锁有几种解决方案。一种是冲刷流水线中所有比放回发射队列的指令年轻的指令，类似Alpha 21264中实现的机制。另一种是推迟发射队列中条目的回收，直到确定这条指令已经被发射成功，但这种方式也需要增加发射队列的大小。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/'>读书笔记</a>, <a href='/categories/%E5%A4%84%E7%90%86%E5%99%A8%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0/'>处理器微架构实现</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E3%80%8A%E5%A4%84%E7%90%86%E5%99%A8%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%88%86%E9%85%8D%E4%B8%8E%E5%8F%91%E5%B0%84%20-%20Li%20Shi&url=https%3A%2F%2Fshili2017.github.io%2Fposts%2FPM3%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E3%80%8A%E5%A4%84%E7%90%86%E5%99%A8%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%88%86%E9%85%8D%E4%B8%8E%E5%8F%91%E5%B0%84%20-%20Li%20Shi&u=https%3A%2F%2Fshili2017.github.io%2Fposts%2FPM3%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fshili2017.github.io%2Fposts%2FPM3%2F&text=%E3%80%8A%E5%A4%84%E7%90%86%E5%99%A8%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%88%86%E9%85%8D%E4%B8%8E%E5%8F%91%E5%B0%84%20-%20Li%20Shi" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fshili2017.github.io%2Fposts%2FPM3%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <a href="http://service.weibo.com/share/share.php?title=%E3%80%8A%E5%A4%84%E7%90%86%E5%99%A8%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%88%86%E9%85%8D%E4%B8%8E%E5%8F%91%E5%B0%84%20-%20Li%20Shi&url=https%3A%2F%2Fshili2017.github.io%2Fposts%2FPM3%2F" data-toggle="tooltip" data-placement="top" title="Weibo" target="_blank" rel="noopener" aria-label="Weibo"> <i class="fa-fw fab fa-weibo"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/BOOKS/">2023年读书记录</a><li><a href="/posts/NOC5/">《片上网络》笔记（五）：流量控制</a><li><a href="/posts/MCCC9/">《内存一致性与缓存一致性》笔记（九）：异构系统的内存一致性与缓存一致性</a><li><a href="/posts/RL4/">CMU 18-643可重构计算笔记-4：类C语言硬件综合的挑战</a><li><a href="/posts/RL1/">CMU 18-643可重构计算笔记-1：FPGA的三个时代</a></ul></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/PM1/"><div class="card-body"> <em class="small" data-ts="1652142300" data-df="ll" > May 10, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《处理器微架构实现》笔记（一）：缓存</h3><div class="text-muted small"><p> 《处理器微架构实现》（英文名为Processor Microarchitecture: An Implementation Perspective）是CMU 18-447 Introduction to Computer Architecture推荐阅读的一本教材。首先介绍的内容是缓存，关于缓存的基本概念在网络上可以找到很多介绍，这里就不再详细展开了。我们在此只讨论一些缓存具体的实现问题。 ...</p></div></div></a></div><div class="card"> <a href="/posts/PM2/"><div class="card-body"> <em class="small" data-ts="1652147820" data-df="ll" > May 10, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《处理器微架构实现》笔记（二）：取指与解码</h3><div class="text-muted small"><p> 取指单元负责向处理器提供接下来要执行的指令，解码单元负责理解一条指令的语义并定义这条指令将如何被执行。 取指单元主要包括一个指令缓存和相关的逻辑。高性能处理器也需要在这一阶段预测下一条指令地址，包括两个部分：分支方向与分支目标地址。下图中是一个简单的取指流水线。 简单的取指流水线 解码单元则负责将原始字节流分割成有效的指令，为指令生成一系列流水线控制信号，包括指令类型、执行什么操作、...</p></div></div></a></div><div class="card"> <a href="/posts/PM4/"><div class="card-body"> <em class="small" data-ts="1652218200" data-df="ll" > May 10, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《处理器微架构实现》笔记（四）：执行</h3><div class="text-muted small"><p> 处理器执行单元 执行阶段真正开始执行一条指令的计算，包括算术操作、访存、分支等，大多数乱序处理器都会采用上图中的执行单元组织结构，灰色阴影区域表示功能单元（FU），如FPU进行浮点运算，ALU进行整数的算术和逻辑运算等。除此之外，执行阶段的另一个重点是旁路网络，以支持指令背对背执行。 功能单元 整数算术和逻辑单元（ALU） ALU对两个整数输入进行操作，并产生一个整数结果。一些复杂...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/PM2/" class="btn btn-outline-primary" prompt="Older"><p>《处理器微架构实现》笔记（二）：取指与解码</p></a> <a href="/posts/PM4/" class="btn btn-outline-primary" prompt="Newer"><p>《处理器微架构实现》笔记（四）：执行</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/shili2017">Li Shi</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0">Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
