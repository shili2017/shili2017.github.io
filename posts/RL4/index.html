<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="CMU 18-643可重构计算笔记-4：类C语言硬件综合的挑战" /><meta property="og:locale" content="en" /><meta name="description" content="原文：The Challenges of Synthesizing Hardware from C-Like Languages." /><meta property="og:description" content="原文：The Challenges of Synthesizing Hardware from C-Like Languages." /><link rel="canonical" href="https://shili2017.github.io/posts/RL4/" /><meta property="og:url" content="https://shili2017.github.io/posts/RL4/" /><meta property="og:site_name" content="Li Shi" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-09-19T03:13:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="CMU 18-643可重构计算笔记-4：类C语言硬件综合的挑战" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-09-19T03:48:09+00:00","datePublished":"2022-09-19T03:13:00+00:00","description":"原文：The Challenges of Synthesizing Hardware from C-Like Languages.","headline":"CMU 18-643可重构计算笔记-4：类C语言硬件综合的挑战","mainEntityOfPage":{"@type":"WebPage","@id":"https://shili2017.github.io/posts/RL4/"},"url":"https://shili2017.github.io/posts/RL4/"}</script><title>CMU 18-643可重构计算笔记-4：类C语言硬件综合的挑战 | Li Shi</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Li Shi"><meta name="application-name" content="Li Shi"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Li Shi</a></div><div class="site-subtitle font-italic">Sleep every day</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/shili2017" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://www.linkedin.com/in/lishi2022" aria-label="linkedin" target="_blank" rel="noopener noreferrer"> <i class="fab fa-linkedin"></i> </a> <a href="javascript:location.href = 'mailto:' + ['shili2048','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>CMU 18-643可重构计算笔记-4：类C语言硬件综合的挑战</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>CMU 18-643可重构计算笔记-4：类C语言硬件综合的挑战</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1663557180" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Sep 19, 2022 </em> </span> <span> Updated <em class="" data-ts="1663559289" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Sep 18, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/shili2017">Li Shi</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2468 words"> <em>13 min</em> read</span></div></div></div><div class="post-content"><p>原文：<a href="https://ieeexplore.ieee.org/document/1704728">The Challenges of Synthesizing Hardware from C-Like Languages</a>.</p><p>我们之所以选择将C语言作为硬件综合的目标，主要原因是大家对C语言已经比较熟悉了。人们也认为通过这种方式，我们很容易实现硬件-软件的协同设计。然而本文认为纯C语言并不是一个面向硬件编程的合适的语言，硬件的一大优势是并行性，但是C不提供原生的并行编程支持，因此综合器要么自动挖掘并行性，要么允许使用语言扩展来显式地定义并行性。本文的主要观点是，高效的硬件设计通常很难用传统的C语言来描述，就算真的可以用C语言来编程，其语义上也和软件上的C几乎没有相似之处。</p><p>本文主要讨论使用类C语言进行硬件综合，不讨论验证和算法设计等内容。对后者而言，类C语言（特别是SystemC和其他变体）已经在广泛使用。</p><h1 id="类c硬件综合语言">类C硬件综合语言</h1><p><a href="/assets/img/Course/18643/4-1.png" class="popup img-link "><img data-src="/assets/img/Course/18643/4-1.png" alt="4-1" class="lazyload" data-proofer-ignore></a> <em>用于硬件综合的类C语言</em></p><p>上表列出了1980年代后期以来提出的一些类C硬件综合语言，如下面的代码是Cones语言的一个例子，函数中的内容会被翻译为组合电路。</p><pre><code class="language-C">INPUTS: IN[5];
OUTPUT: OUT[3];
rd53()
{
    int count, i;
    count = 0;
    for (i=0 ; i&lt;5 ; i++)
        if (IN[i] == 1)
            count = count + 1;
    for (i=0 ; i&lt;3 ; i++) {
        OUT[i] = count &amp; 0x01;
        count = count &gt;&gt; 1;
    }
}
</code></pre><p>下面的代码是HardwareC中的最大公约数算法，HardwareC是一种行为硬件语言。</p><pre><code class="language-C">#define SIZE 8
process gcd (xi, yi, rst, ou)
    in port xi[SIZE], yi[SIZE];
    in port rst;
    out port ou[SIZE];
{
    boolean x[SIZE], y[SIZE];

    write ou = 0;
    if ( rst ) &lt;
    x = read(xi);
    y = read(yi);
    &gt;

    if ((x != 0) &amp; (y != 0))
        repeat {
            while (x &gt;= y)
                x = x – y;
            &lt;
                x = y; /* swap x and y */
                y = x;
            &gt;
        } until (y == 0);
    else
        x = 0;
    write ou = x;
}
</code></pre><p>SystemC是一种支持硬件和系统建模的C++变体，通过C++的类来对层次结构进行建模，并通过组合和时序过程来描述硬件，下面的代码是SystemC描述的硬件，功能是两位十进制数字到七段数码管的解码器，解码器产生组合逻辑，计数器产生时序逻辑。</p><pre><code class="language-C">#include “systemc.h”
#include &lt;stdio.h&gt;
struct decoder : sc_module {
    sc_in&lt;sc_uint&lt;4&gt; &gt; number;
    sc_out&lt;sc_bv&lt;7&gt; &gt; segments;

    void compute() {
        static sc_bv&lt;7&gt; codes[10] = {
            0x7e, 0x30, 0x6d, 0x79, 0x33,
            0x5b, 0x5f, 0x70, 0x7f, 0x7b };
        if (number.read() &lt; 10)
            segments = codes[number.read()];
    }

    SC_CTOR(decoder) {
        SC_METHOD(compute);
        sensitive &lt;&lt; number;
    }
};

struct counter : sc_module {
    sc_out&lt;sc_uint&lt;4&gt; &gt; tens;
    sc_out&lt;sc_uint&lt;4&gt; &gt; ones;
    sc_in_clk clk;

    void tick() {
        int one = 0, ten = 0;
        for (;;) {
            if (++one == 10) {
                one = 0;
                if (++ten == 10) ten = 0;
            }
            ones = one;
            tens = ten;
            wait();
        }
    }

    SC_CTOR(counter) {
        SC_CTHREAD(tick, clk.pos());
    }
};
</code></pre><p>SpecC语言则是ANSI C的超集，增加了许多系统和硬件建模结构，包括FSM、并发、流水线等，下面的代码展示了SpecC的可综合RTL语言描述的状态机，其中<code class="language-plaintext highlighter-rouge">wait(clk)</code>表示时钟周期边界。</p><pre><code class="language-C">behavior even(
    in event clk,
    in unsigned bit[1] rst,
    in bit[31:0] Inport,
    out bit[31:0] Outport,
    in bit[1] Start,
    out bit[1] Done,
    out bit[31:0] idata,
    in bit[31:0] iocount,
    out bit[1] istart,
    in bit[1] idone,
    in bit[1] ack_istart,
    out bit[1] ack_idone)
{
    void main(void) {
        bit[31:0] ocount;
        bit[31:0] mask;
        enum state { S0, S1, S2, S3 } state;

        state = S0;

        while (1) {
            wait(clk);
            if (rst == 1b) state = S0;
            switch (state) {
                case S0:
                    Done = 0b;
                    istart = 0b;
                    ack_idone = 0b;
                    if (Start == 1b) state = S1;
                    else state = S0;
                    break;
                case S1:
                    mask = 0x0001;
                    idata = Inport;
                    istart = 1b;
                    if (ack_istart == 1b)
                    state = S2;
                    else state = S1;
                    break;
                case S2:
                    istart = 0b;
                    ocount = iocount;
                    if (idone == 1b) state = S3;
                    else state = S2;
                    break;
                case S3:
                    Outport = ocount &amp; mask;
                    ack_idone = 1b;
                    Done = 1b;
                    if (idone == 0) state = S0;
                    else state = S3;
                    break;
            }
        }
    }
};
</code></pre><h1 id="并发">并发</h1><p>硬件和软件最大的区别在于执行模型，软件遵循冯诺依曼结构的基于内存的顺序执行模型，而硬件则从本质上来说就是并发的。并发编程仍然很困难，一方面是因为难度较大，另外一方面则是关于并行编程模型的分歧，如选择共享内存还是消息传递。</p><p>在顺序代码中挖掘并行性有三种主要方法，分别为指令级并行（已经在乱序超标量处理器中广泛应用）、流水线（会涉及到数据与控制依赖的问题）、进程级并行（取决于算法，且很难自动识别，需要程序员手动控制）。</p><p>有两种方法在C中实现并发。第一种方法在语言中添加并行结构，让程序员手动控制，另一种方法是让编译器自动识别并行性。这两种方法有各自的缺点，后者为编译器开发增加了难度，前者则要求程序员以一种全新的思维方式去编程，一个好的硬件规范语言必须能够有效表达并行算法。</p><h1 id="时序">时序</h1><p>C语言中很难实现时序约束，也没有规定每条指令需要的时间，但为了实现硬件设计的性能目标，我们需要合适的指定并实现时序约束的机制。下面的代码就很难说明这个循环需要多少周期，不同的语言对此的解释并不一致。</p><pre><code class="language-C">for (i = 0 ; i &lt; 8 ; i++) {
    a[i] = c[i];
    b[i] = d[i] || f[i];
}
</code></pre><p>编译器使用各种技术插入时钟周期边界，手动或自动。一个好的硬件综合语言需要可以明确或通过约束来指定时序，但也不应该要求程序员提供太多细节。</p><h1 id="数据类型">数据类型</h1><p>数据类型是硬件和软件语言之间的另一个主要区别。C几乎不支持小于一个字节的类型，因此纯C的代码很容易被翻译成不必要的硬件。</p><p>编译器采用三种方法将硬件类型引入C程序。第一种是允许在语言之外调整数据的宽度，第二种是在C中添加硬件类型，基于C++语言的第三种方法是通过C++的类型系统提供类似硬件的类型。一个好的硬件语言需要一个允许精确定义硬件类型的类型系统，C++相比C显得更合适。</p><h1 id="通信">通信</h1><p>类C语言建立在非常灵活的内存通信模型之上，隐含地将所有内存位置视为访问成本相同，但在现代内存层次结构中并非如此。设计人员通常可以预测这些存储器的行为并更有效地使用，但非常困难，且类C语言对内存访问提供的辅助支持很少。为了避免过长且无法预测的通信延迟，硬件设计人员根据系统的需要使用各种机制，从简单的线路到复杂的通信协议。</p><h2 id="指针的问题"><span class="mr-2">指针的问题</span><a href="#指针的问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>由于指针的不确定性，软件中的通信模式通常很难事先确定，指针别名也是一个很严重的问题。尽管可以使用指针分析来估计C程序的通信模式，但是精确的分析是不可能的，只能采取保守的方法，也会导致额外不必要的开销。</p><h2 id="内存与通信"><span class="mr-2">内存与通信</span><a href="#内存与通信" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们可以把类C语言大致分为两组。第一组忽略C的内存模型，不支持数组和指针，只关注局部变量；第二组则尽可能实现C的所有数据类型，支持struct、数组等多种存储方式。</p><p>硬件和软件在这方面的设计差异也是巨大的。软件的通信方式是面向事务的，但硬件则是通过物理上的连线的。软件设计者通常会忽略内存访问的模式，但硬件设计者一开始就要详细描述每个通信的通道，并最小化通信的开销。</p><h1 id="元数据">元数据</h1><p><a href="/assets/img/Course/18643/4-2.png" class="popup img-link "><img data-src="/assets/img/Course/18643/4-2.png" alt="4-2" class="lazyload" data-proofer-ignore></a> <em>硬件语言面临的巨大挑战</em></p><p>由于硬件的层次远低于软件，有更多方法可以在硬件中实现特定的C结构。例如加法运算，CPU可能只有一条有用的加法指令，而在硬件中却有大量不同的加法器结构。因此，硬件的翻译过程比软件的翻译需要做出更多的决定，此外，正确的决策因设计约束而异，期望所有这些决策都是自动化的仍然是不现实的。</p><p>尽管我们似乎可以使用C++的运算符重载机制来手动指定各种约束，但这种机制的实现可能仍然非常困难。C++的重载机制是使用参数类型来定义的，但硬件中算法的选择通常由资源限制决定。</p><p>我们可以采用两种方法来指定各种元数据：放置在程序中（注释、pragma、添加的结构等）或者程序之外（文本文件、GUI等）。一个好的硬件规范语言需要一种方法来指导综合过程在不同的实现中进行选择，在功率和速度之间进行权衡。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/course/'>Course</a>, <a href='/categories/cmu-18-643%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97/'>CMU 18-643可重构计算</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=CMU%2018-643%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97%E7%AC%94%E8%AE%B0-4%EF%BC%9A%E7%B1%BBC%E8%AF%AD%E8%A8%80%E7%A1%AC%E4%BB%B6%E7%BB%BC%E5%90%88%E7%9A%84%E6%8C%91%E6%88%98%20-%20Li%20Shi&url=https%3A%2F%2Fshili2017.github.io%2Fposts%2FRL4%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=CMU%2018-643%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97%E7%AC%94%E8%AE%B0-4%EF%BC%9A%E7%B1%BBC%E8%AF%AD%E8%A8%80%E7%A1%AC%E4%BB%B6%E7%BB%BC%E5%90%88%E7%9A%84%E6%8C%91%E6%88%98%20-%20Li%20Shi&u=https%3A%2F%2Fshili2017.github.io%2Fposts%2FRL4%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fshili2017.github.io%2Fposts%2FRL4%2F&text=CMU%2018-643%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97%E7%AC%94%E8%AE%B0-4%EF%BC%9A%E7%B1%BBC%E8%AF%AD%E8%A8%80%E7%A1%AC%E4%BB%B6%E7%BB%BC%E5%90%88%E7%9A%84%E6%8C%91%E6%88%98%20-%20Li%20Shi" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fshili2017.github.io%2Fposts%2FRL4%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <a href="http://service.weibo.com/share/share.php?title=CMU%2018-643%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97%E7%AC%94%E8%AE%B0-4%EF%BC%9A%E7%B1%BBC%E8%AF%AD%E8%A8%80%E7%A1%AC%E4%BB%B6%E7%BB%BC%E5%90%88%E7%9A%84%E6%8C%91%E6%88%98%20-%20Li%20Shi&url=https%3A%2F%2Fshili2017.github.io%2Fposts%2FRL4%2F" data-toggle="tooltip" data-placement="top" title="Weibo" target="_blank" rel="noopener" aria-label="Weibo"> <i class="fa-fw fab fa-weibo"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/BOOKS/">2023年读书记录</a><li><a href="/posts/NOC5/">《片上网络》笔记（五）：流量控制</a><li><a href="/posts/MCCC9/">《内存一致性与缓存一致性》笔记（九）：异构系统的内存一致性与缓存一致性</a><li><a href="/posts/RL4/">CMU 18-643可重构计算笔记-4：类C语言硬件综合的挑战</a><li><a href="/posts/RL1/">CMU 18-643可重构计算笔记-1：FPGA的三个时代</a></ul></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/RL1/"><div class="card-body"> <em class="small" data-ts="1661751240" data-df="ll" > Aug 29, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>CMU 18-643可重构计算笔记-1：FPGA的三个时代</h3><div class="text-muted small"><p> 原文：Three Ages of FPGAs: A Retrospective on the First Thirty Years of FPGA Technology. Xilinx在1984年首次推出第一款FPGA，在随后的30年中，FPGA容量增加了10000倍，速度提高了100倍，单位成本和能耗降低了1000倍，如下图所示。这种进步很大程度上是由工艺进步推动的，但不完全是。本文回顾...</p></div></div></a></div><div class="card"> <a href="/posts/RL2/"><div class="card-body"> <em class="small" data-ts="1661894520" data-df="ll" > Aug 30, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>CMU 18-643可重构计算笔记-2：Altera FPGA架构白皮书（2006）</h3><div class="text-muted small"><p> 原文：Altera FPGA Architecture Whiter Paper. 这篇文章是Altera在2006年发布的FPGA架构白皮书，简单介绍了其当时的FPGA架构，包括LUT与ALM的设计、相比基本的LUT的优势、路由架构等内容。 Logic Fabric 在Altear的FPGA器件上，一个最基本的模块是Adaptive Logic Module，即ALM，如上图所示...</p></div></div></a></div><div class="card"> <a href="/posts/RL3/"><div class="card-body"> <em class="small" data-ts="1662088140" data-df="ll" > Sep 2, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>CMU 18-643可重构计算笔记-3：FPGA架构的原理与演进</h3><div class="text-muted small"><p> 原文：FPGA Architecture: Principles and Progression. FPGA已被广泛用于实现来自不同领域的无数应用。由于其低级硬件可重构性，与定制设计的芯片相比，FPGA具有更快的设计周期和更低的开发成本。FPGA架构的设计涉及许多不同的设计选择，从高级架构参数到晶体管级实现细节，目标是制造高度可编程的器件，同时最大限度地减少可重构性的面积和性能成本。本文介...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/RL3/" class="btn btn-outline-primary" prompt="Older"><p>CMU 18-643可重构计算笔记-3：FPGA架构的原理与演进</p></a> <a href="/posts/VM1/" class="btn btn-outline-primary" prompt="Newer"><p>《虚拟内存的架构和操作系统支持》笔记（一）：基础</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/shili2017">Li Shi</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0">Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
