---
title: 《内存一致性与缓存一致性》笔记（六）：缓存一致性协议
date: 2022-07-03 15:44:00 -0700
categories: [内存一致性与缓存一致性]
tags: []
img_path: /assets/img/MCCC/
---

我们从这一节开始讨论缓存一致性协议，包括协议的工作原理、如何定义缓存一致性协议、协议的设计空间等。

我们先前已经讨论过缓存一致性协议的目标，具体包括：

1. 单写多读（single-writer-multiple-reader, SWMR）不变性：对任何内存地址A，在任何时间点上只存在一个可以向A写入的内核，但可以存在多个从A读取的内核。

1. 数据-值（data-value）不变性：一个内存位置在一个时间片开始时的值与该内存位置在其上一个时间片结束时的值相同。

为了实现这些性质，我们把每个存储结构（包括私有缓存、LLC、内存）与一致性控制器连接起来，构成一个分布式系统，控制器之间交换信息。下面两张图展示了缓存控制器与LLC/内存控制器的功能。

![6-1](6-1.png)
_缓存控制器_

![6-2](6-2.png)
_LLC/内存控制器_

## 定义缓存一致性协议

我们通过规定控制器的行为来定义一致性协议，通常用表格的形式来说明，如下图所示。

![6-3](6-3.png)
_表格形式的一致性定义_

## 最简单的一致性协议

我们用图和表格来展示这种只有两个状态的一致性协议，包括I状态和V状态。

![6-4](6-4.png)
_缓存控制器中不同状态之间的转换_

![6-5](6-5.png)
_缓存控制器定义_

![6-6](6-6.png)
_内存控制器定义_

## 协议设计空间

协议设计者需要定义每种控制器中的状态、事务、事件以及状态转换。稳定状态和事务的选择通常和一致性协议的其他部分无关，但事件、状态转换以及过渡状态高度依赖于一致性协议本身。

### 状态

在单处理器系统中，一个缓存行可以只有一个性质，即validity，如果采用写回策略还有一个性质，即dirtiness，但是在多处理器系统中可能会有其他状态，如exclusivity和ownership。我们现在给出如下定义：

1. Validity：指缓存行包含了这个block的最新值，可以读取，但只有同时为exclusive的时候才可以写入。

1. Dirtiness：指缓存行包含了最新的值且与LLC/内存中的值不同，且缓存控制器最终用这个新的值更新LLC/内存，反义词为clean。

1. Exclusivity：指缓存行是系统中唯一的私有缓存副本。

1. Ownership：如果一个缓存控制器或内存控制器负责响应一个block的一致性请求，那么这个控制器就是该block的所有者。

#### 稳定状态

许多一致性协议使用MOESI模型中的一个子集，最基本的三个状态是MSI，下图说明了MOESI中每种状态具有哪些特性。

![6-7](6-7).png
_MOESI状态_

#### 过渡状态

在复杂的协议中，我们可能会有几十个过渡状态，我们用XY_Z的形式来表示这些状态，如IV_D表示在Invalid状态中，准备进入Valid状态，且正在等待DataResp。

#### LLC/内存中的状态

有两种命名这些状态的方法：

1. 以缓存为中心：一个缓存行在LLC和内存中的状态是该行在缓存中的状态的集合，例如，如果该行在所有缓存中状态都是I，那么在LLC/内存状态也是I，如果在一个或多个缓存中的状态是S，那么LLC/内存状态就是S，如果在一个缓存中状态为M，那么LLC/内存状态就是M。

1. 以内存为中心：一个缓存行在LLC/内存中的状态对应于内存控制器对该行的权限（而不是缓存的权限），例如，如果该行在所有缓存中状态都是I，那么在LLC/内存控制器中的状态就是O（而不是以缓存为中心的方法中的I），如果在一个或多个缓存中的状态是S，那么LLC/内存的状态也是O，如果在一个缓存中状态为M或O，那么LLC/内存的状态就是I。

后面我们都使用以缓存为中心的命名方法来表示LLC/内存中的缓存行的状态。

### 事务

大多数协议都有一组类似的事务，下表列出了一组常见事务。

![6-8](6-8.png)
_常见事务_

![6-9](6-9.png)
_常见的由内核向缓存控制器发出的请求_
