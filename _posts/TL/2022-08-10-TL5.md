---
title: TileLink笔记（五）：TL-C
date: 2022-08-11 00:02:00 -0400
categories: [TileLink]
tags: []
img_path: /assets/img/TL/
---

TileLink缓存支持级（TL-C）给主端代理提供缓存共享数据块副本的能力，保证缓存一致性。本章描述TL-C中缓存的数据副本上允许进行哪些访存操作，以及用来传输数据块的缓存的消息类型，实现中所定义的一致性协议描述了副本和权限如何通过具体的TileLink代理网络传输以回复所接收的存储访问操作，但具体的一致性协议描述不在TileLink协议内容范围内。

TL-C新添加了三种操作、三个通道、一个五步的消息序列模板以及十种消息类型。

新的操作transfer可以创建或者清除数据块的缓存副本。转换操作不会修改数据块的值，但是会改变他们的读写权限。转换操作可以与之前定义的TL-UL、TL-UH访存操作无缝协作，保证操作进行序列化的正确性。

可缓存性是存储地址范围的一个属性，一个TileLink的实现需保证避免无法缓存地址范围的副本出现。

## 使用TileLink实现缓存一致性

所有基于Tilelink的一致性协议都由一系列操作组成，通过这些操作，可以完成读写数据块权限的在转变。在代理对已缓存的副本执行响应的操作之前，必须获得正确的权限。当代理希望在本地处理一个访问操作时，它必须首先使用转换操作来获得必要的权限。转换操作在网络上创建或删除副本，从而修改每个副本可以提供的权限。

代理中数据块副本的基本权限可以包括：None、Read或Read+Write。缓存架构中副本 可用的权限取决于缓存层次结构中副本的当前存在情况，如下所述。

对于任何给定的地址，在给定主端和拥有该地址范围的从端之间都只会存在一个具体的路径。在TileLink网络DAG中，所有这些路径都覆盖会形成一个树，根节点上仅有一个从端节点。对于每个地址，此树包含所有针对该地址的操作执行的路径。如果我们省略了所有不能缓存数据的代理，那么就会留下一个描述所有可能缓存该地址数据的缓存代理位置的树。

在逻辑时间的任意时刻，这些代理的某些子集真正包含缓存数据的副本。这些代理形成 了一致性树 。包容性（Inclusive）的TileLink一致性协议要求树在响应内存访问操作时进行提权（Grow）和降权（Shrink）操作。图中的每个节点都属于树中的位置，分为以下四类：

- Nothing：当前没有缓存数据副本的节点，没有读写权限。

- 主干（Trunk）：在顶点（Tip）和根（Root）之间的路径上拥有缓存副本的节点，具有其副本的读权限，该副本可能包含脏数据。

- 无分支的顶点（Tip with no Branches）：具有缓存副本的节点，且可以用作内存访问序列化，对其拥有的可能包含脏数据的副本具有读写权限。

- 有分支的顶点（Tip with Branches）：具有缓存副本的节点，且可以用作内存写入序列化，对其拥有的可能包含过去写入的脏数据的副本具有读写权限。

- 分支（Branch）：该节点由Trunk结点分出，具有只读数据缓存副本。

![5-1](5-1.png)
_同一个TileLink拓扑图中几种可能的一致性树_

上图例举了几个覆盖在单个TileLink网络上的一致性树。在A中，树的根节点有唯一的 副本，这使得它既是树的根节点，也是树的顶端节点。在B中，主端通过提升主干的特权 (Grow)，获得读写权限，直到其位于顶点处。在C中，另一个主端通过扩展一个分支获得了读权限，这意味着之前的顶点现在也是一个只读分支，且公共的父节点是主干节点。在D中，其他主端也升级为分支，进一步将尖端向根部移动，而最初的请求者已经主动修剪了其分支。

![5-2](5-2.png)
_权限与访存操作之间的关系_

上表分别描述哪种状态下的节点上可以执行哪些访问操作，并且这还定义这些状态在一致性树中的位置，另外协议具体定义的状态可以基于这些基本状态。

### 操作

三个新操作统称为transfer操作，原因是这些操作将数据块的副本传输到内存层次结构中的新位置，包括：

- Acquire：在请求主端中创建块（或其特定权限）的新副本。

- Release：从请求的主端将块的副本（或其特定权限）释放回从端。

- Probe：强制将块的副本（或其特定权限）从主端移到发起请求的从端。

Acquire操作要么以扩展树干的形式，要么以从现存的分支或者尖端添加新的分支的形式来拓展树。在新的分支生成前，旧的主干或分支可能需要递归的Probe方法进行修剪。为了响应缓存容量冲突，可通过Release操作主动裁剪分支。

### 通道

为了支持转换操作，TL-C在执行内存访问操作所需的两个基本通道上添加了三个新通道。A和D通道也被重新用于发送额外的消息，以实现转换操作。转换操作使用的五个通道分别是：

- 通道A：主端为了读取或写入缓存块副本而发起对权限的请求。

- 通道B：从端查询或修改主端对缓存数据块的权限，或将内存访问前递（forward）给主端。

- 通道C：主端响应通道B传输的消息，可能会释放带有任脏数据块的权限。也用于主动回写脏的缓存数据。

- 通道D：从端向原始请求者提供数据或权限，授予对缓存块的访问权。也用于确认脏数据的主动写回。

- 通道E：主端提供此次事务完成的最终确认消息，从端可用来事务序列化。

### 消息

![5-3](5-3.png)
_TL-C转换操作消息总览_

TL-C规定了五个通道内的十种消息，如上表所示。注意某种请求消息可能会对应多种回复消息，取决于从端如何返回数据副本。

### 权限转换

Transfer是对权限进行操作，因此组成其的消息必须指定预期的结果：升级到更高权限，降级到更低权限，或者一个保持权限不变的无操作，这些变化是根据它们对特定地址的一致性树形状的影响来指定的。

![5-4](5-4.png)
_权限转换的分类与编码_

上表展示了基于TileLink的一致性协议所需的权限转换，被分成四个子集：

- Prune：权限降级，缩小一致性树。相比过去，完成操作之后具有较低的权限。

- Grow：权限升级，增大一致性树。相比过去，完成操作之后具有较高的权限。

- Report：包含权限保持不变，但报告当前权限状态。

- Cap：包含权限更改，但不指定原始权限是什么，而只指定它们应该成为什么。

## 消息流与波形

Transfer操作引入新的事务流，这些事务流可以组成完整的缓存一致性协议事务。下图描述了三个新消息流。

![5-5](5-5.png)
_TileLink操作的事务流_

![5-6](5-6.png)
_包含了所有三种transfer操作的事务流_

上图展示了一个消息流，包含了所有三种transfer操作，具体如下：

1. 缓存主代理向从代理发送Acquire。

1. 为保证给响应消息留足够空间，主代理主动发送Release，即写回操作。

1. 从代理访问存储结构，以完成写操作。

1. 从代理通过ReleaseAck确认写回操作已完成。

1. 从代理向其他主代理发送必需的Probe。

1. 从代理等待所有被Probe的主代理返回ProbeAck。

1. 若有需要，从代理还需访问存储结构。

1. 从代理向原请求设备发送Grant。

1. 原主代理以GrantAck说明此次事务成功完成。

虽然这三个流程构成了所有涉及缓存块传输的TileLink事务的基础，但是当它们临时地重叠或分层地组合时，会出现一些边界情况。现在我们将讨论TileLink如何管理并发性，并分散到各主从代理之间。

TileLink假设消息并不完全是点到点的有序的传递，来自高优先级通道的消息必须能够在网络中先于较低优先级的消息处理，从端充当连接到它的所有主端的一个同步节点。由于每个事务都必须通过发送给从端的一条Acquire消息作为初始消息，因此从端可以轻松对事务进行排序。一个非常安全的实现方式是一次只接受一个事务，但是这种方式对性能影响巨大，而且事实证明我们可以在继续提供正确的序列化的同时增加并发性。尽管事务有着天然的分布式属性，对代理的行为施加一些限制，仍能够保证事务间的有序性。下图描述了每种操作并发的一些限制。

![5-7](5-7.png)
_操作流_

对TileLink代理上的并发限制在发射或阻塞请求消息方面最容易理解。所有请求消息都会引发响应消息，并且响应消息保证最终产生向前推进的效果，但是在某些情况下，在收到还未处理的响应消息之前，不应该发出针对同一块的递归请求消息。我们按照请求消息类型来对这些情况分类：

- Acquire：如果在块上有一个pending的Grant块，主端就不应发射一个Acquire。一旦Acquire被发出，主端不应该在该块发出进一步的Acquire，直到它收到一个Grant。

- Grant：在块上有一个pending的ProbeAck时，从端不应该发射Grant。一旦发出了一个Grant时，从端不应该在该块上发射Probe，直到它收到一个GrantAck。

- Release：在块上有一个pending的Grant时，主端不应该发射一个Release。一旦发出了一个Release后，主端不能发射ProbeAck，直到它收到来自从端确认写回操作完成的ReleaseAck。

- Probe：在块上有一个pending的GrantAck时，从端不应该发射一个Probe。一旦发射了一个Probe，从端不能进一步发射Probe，直到它收到一个ProbeAck。

![5-8](5-8.png)
_从代理端通过GrantAck来序列化相互交织的消息流的Grant和Probe_

上图展示了一个消息流，包含了Grant和Probe，具体如下：

1. 主代理A先发送Acquire，但由于网络延迟，后到从代理。

1. 主代理B后发送Acquire，但先到达从代理，被序列化在A的前面。

1. 从代理向A发送Probe，即使A还在等待Grant，也必须先处理Probe。

1. 从代理接收到A的ProbeAck后，向B发送Grant。

1. 从代理接收到A的Acquire，但由于正等待B的GrantAck，所以现在还不能处理这个请求。

1. 一旦接收到B的GrantAck，A的事务就可以正常处理了。

1. 从代理向B发送Probe，但这个操作被在上一个Grant之后。

1. 从代理向A发送合适类型的Grant(包括数据副本)，说明A在Acquire后被Probe过。

![5-9](5-9.png)
_从代理端序列化相互交织的消息流的Release和Probe_

上图展示了一个消息流，包含了Release和Probe，具体如下：

1. 主代理A向从代理发送Acquire。

1. 与此同时，主代理B通过Release主动剔除相同的数据缓存块。

1. 从代理向B发送Probe。

1. 从代理等待每个发送出的Probe，但可以处理主动发起的Release。从代理发送ReleaseAck确认主动写回的操作完成。

1. B在接收到写回确认前不处理Probe。

1. 在从代理接收到B的ProbeAck后，A的事务就可以正常执行了。

## TL-C消息

权限转换新增的三个通道有六个新消息，另外新增了一个通道A消息、三个通道D消息。新的通道是B、C和E，新的消息类型是Acquire、Probe、ProbeAck[Data]、Release[Data]、ReleaseAck、Grant[Data]和GrantAck。

### AcquireBlock

AcquireBlock消息是主代理计划在本地缓存数据块的副本时，发起的请求消息类型，主代理还可以使用这种消息类型来升级他们已缓存块上的权限（例如，获得只读副本的写权限），与Get消息一样，Acquire消息本身不包含数据，下表说明了通道A内该消息的信号编码。

![5-10](5-10.png)
_AcquireBlock消息的编码_

### AcquirePerm

AcquirePerm消息是主代理计划升级缓存数据块的权限，且无需提供数据副本时，发起的请求消息类型，下表说明了通道A内该消息的信号编码。

![5-11](5-11.png)
_AcquirePerm消息的编码_

### ProbeBlock

ProbeBlock消息是从代理用来查询或修改由特定主代理存储的数据块的缓存副本的权限的请求消息，从代理响应另一个主代理的Acquire或主动发起，可以取消主代理对一块缓存块的权限，下表说明了通道B内该消息的信号编码。

![5-12](5-12.png)
_ProbeBlock消息的编码_

### ProbePerm

ProbePerm消息是从代理用来查询或修改由特定主代理存储的数据块的缓存副本的权限的请求消息，从代理响应另一个主代理的Acquire或主动发起，可以取消主代理对一块缓存块的权限，不过和ProbeBlock不同的是，ProbePerm要求不需要提供数据副本就可以发起请求，下表说明了通道B内该消息的信号编码。

![5-13](5-13.png)
_ProbePerm消息的编码_

### ProbeAck

ProbeAck消息是主代理用来回复Probe的消息，下表说明了通道C内该消息的信号编码。

![5-14](5-14.png)
_ProbeAck消息的编码_

### ProbeAckData

ProbeAckData消息是主代理使用的响应消息，用于确认接收到Probe，并写回发送请求的从代理所需的脏数据，下表说明了通道C内该消息的信号编码。

![5-15](5-15.png)
_ProbeAckData消息的编码_

### Grant

Grant消息是一个响应也是一个请求消息，从代理使用它来确认接收到一个Acquire，并提供访问缓存块的权限给原始发送请求的主代理，下表说明了通道D内该消息的信号编码。

![5-16](5-16.png)
_Grant消息的编码_

### GrantData

GrantData消息既是响应也是请求消息，从代理使用它向原始请求主代理提供确认消息以及数据块副本，下表说明了通道D内该消息的信号编码。

![5-17](5-17.png)
_GrantData消息的编码_

### GrantAck

GrantAck响应消息被主代理用来提供事务完成的最终确认消息，同时也被从代理用来确 保操作的全局序列化，下表说明了通道E内该消息的信号编码。

![5-18](5-18.png)
_GrantAck消息的编码_

### Release

Release消息是主代理用来主动降低其对一个缓存数据块的权限的请求消息，下表说明了通道C内该消息的信号编码。

![5-19](5-19.png)
_Release消息的编码_

### ReleaseData

ReleaseData消息是主代理发起的请求消息，用于主动降低对一块缓存数据块的权限，并将脏数据写回从代理，下表说明了通道C内该消息的信号编码。

![5-20](5-20.png)
_ReleaseData消息的编码_

### ReleaseAck

ReleaseAck消息是一个从代理发起的响应消息，用来响应Release[Data]，用于确保从代理的操作的全局序列化，下表说明了通道D内该消息的信号编码。

![5-21](5-21.png)
_ReleaseAck消息的编码_

## TL-UL和TL-UH在通道A与通道D上的消息

TL-C规定了TL-UL和TL-UH现有消息的权限转换：

- Get操作隐式地将权限Cap为None（Invalid）。

- PutFullData、PutPartialData、ArthmeticData、LogicalData隐式地将权限Cap为非Read+Write（主干或顶点），即None（Invalid）或Read（分支）。

## TL-UL和TL-UH在通道B与通道C上的消息

除了三个新操作（Acquire、Probe、Release）之外，TL-C重新定义了所有在通道B和C上的TL-UH的操作，这允许那些通道被用来转发Access和Hint操作给远端的缓存数据所有者。换句话说，其实现可以选择使用基于更新的协议，而不是基于失效的协议。

具体的消息类型和TL-UH的消息类似，可以参考原文，此处篇幅有限就不再详细阐述了。
